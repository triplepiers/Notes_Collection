# ä¸€äº›åŸºç¡€è¯­æ³•

## Sampleï¼šçŒœæµ‹éšæœºæ•°

### æ ‡å‡† I/O æ“ä½œ

å…¶å®åœ¨ Hello World ä¸­ï¼Œæˆ‘ä»¬å·²ç»æŒæ¡äº†ä½¿ç”¨ `println!` å®è¿›è¡Œè¾“å‡ºçš„æ–¹æ³•

åœ¨è¿™ä¸ªå° sample ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•è°ƒç”¨æ ‡å‡†I/Oåº“å¯¹è¾“å…¥è¿›è¡Œè¯»å–

```rust
use std::io;   // è°ƒç”¨æ ‡å‡†I/Oåº“

let mut guess = String::new();    // ::fn() è¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªå±äºç±»ï¼ˆè€Œéå®ä¾‹ï¼‰çš„é™æ€æ–¹æ³•
io::stdin()
    .read_line(&mut guess)
    .expect("æ— æ³•è¯»å–è¡Œ");          // å¼‚å¸¸å¤„ç†

println!("You guess: {}", guess); // {} æ˜¯è¾“å‡ºå ä½ç¬¦
```

### ç”Ÿæˆéšæœºæ•°
> rand å±…ç„¶ä¸åœ¨æ ‡å‡†åº“é‡Œä½ ä¿¡ï¼Ÿ

é¦–å…ˆï¼Œä½ éœ€è¦ç”¨ Cargo é…ç½®ä¾èµ–ã€‚å…·ä½“è¡¨ç°ä¸ºï¼Œåœ¨ `Cargo.toml` ä¸‹å¢åŠ ä»¥ä¸‹ä¿¡æ¯ï¼š

```
[dependencies]
rand = "^0.3.14"   // åŒ…å = "ç‰ˆæœ¬", ^ è¡¨ç¤ºä»»ä½•ä¸æŒ‡å®šç‰ˆæœ¬å…¼å®¹çš„ç‰ˆæœ¬
```

> å…¶å®ä¹Ÿå¯ä»¥ç›´æ¥åœ¨é¡¹ç›®ç›®å½•ä¸‹ `cargo add rand`

ç„¶åä½ å°±å¯ä»¥è°ƒåº“ç”Ÿæˆéšæœºæ•°äº†ï¼š

```rust
use rand::Rng; // ç±»ä¼¼äº Java çš„æ¥å£ï¼Œå†…å«å¾ˆå¤šæ–¹æ³•

// ç”Ÿæˆä¸€ä¸ªå±äº [1, 101) èŒƒå›´å†…çš„å¸¸é‡
// æ—§ç‰ˆæœ¬çš„å‚æ•°ä¹¦å†™æ–¹å¼æ˜¯ gen_range(1, 101)
let secret = rand::thread_rng().gen_range(1..101); 
```

### å®Œæ•´ç¨‹åºç¤ºä¾‹

```rs
use std::io;
use std::io::Write;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    // ç”Ÿæˆéšæœºæ•° [1,100]
    let secret_num = rand::thread_rng()
        .gen_range(1,101); // é»˜è®¤ä¸º i32ï¼Œä½†å¯ä»¥è‡ªåŠ¨æ¨æ–­ä¸º u32

    // æ­»å¾ªç¯å•Šå®¶äººä»¬
    loop {
        // ä¸æ¢è¡Œæ‰“å°
        print!("Guess a number between [1,100]: ");
        let _ = io::stdout().flush();     // æ ‡å‡†è¾“å‡ºé‡åˆ° \n æ‰ä¼šè‡ªåŠ¨è¾“å‡º

        // Get Input
        let mut ipt = String::new();
        io::stdin()                       // io::Result ä¸º {OK, Err} æšä¸¾ç±»å‹
            .read_line(&mut ipt)          // å¼•ç”¨é»˜è®¤ä¹Ÿæ˜¯ä¸å¯å˜çš„ ...
            .expect("[Error] Fail to read input");

        // Shadiwing: String => Number
        let ipt:i32 = match ipt.trim().parse() {
            Ok(num) => num,
            Err(_) => continue            // ç›´æ¥ç”¨ expect ä¼šå´©æºƒæ€§é€€å‡º
        };
        
        // Compare
        match ipt.cmp(&secret_num) {
            Ordering::Less => println!("Too Small !!!"),
            Ordering::Greater => println!("Too Big !!!"),
            Ordering::Equal => {
                println!("You Win ~");
                break;
            }
        }
    }
}
```

## 1 å˜é‡ä¸å¸¸é‡

### å˜é‡
- å‘½åéµå¾ª snake case è§„èŒƒï¼ˆå…¨å°å†™ã€é€šè¿‡ `_` åˆ†éš”ï¼‰
- é€šè¿‡ `let` å…³é”®å­—è¿›è¡Œå£°æ˜ï¼Œä¸”é»˜è®¤ä¸º **ä¸å¯å˜**
- å¦‚éœ€å£°æ˜å¯å˜å˜é‡ï¼Œè¯·åœ¨å£°æ˜æ—¶é™„åŠ  `mut` å…³é”®å­—

```rs title="å¥‡å¦™sample"
let x = 5;
let y = {      // åˆ›å»ºå—è¡¨è¾¾å¼ = æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼
    let x = 1; // è¿™æ˜¯è¯­å¥
    x+3        // è¿™æ˜¯è¡¨è¾¾å¼ï¼ˆç»“å°¾æ²¡æœ‰ ;ï¼‰
};             // y = 1+3 = 4
```

### å¸¸é‡
- é€šå¸¸ä½¿ç”¨ *å…¨å¤§å†™* å­—æ¯å‘½åï¼Œä¸åŒå•è¯é—´é€šè¿‡ `_` åˆ†éš”
- *ä¸å…è®¸* ä½¿ç”¨ `mut` => å®ƒæ°¸è¿œä¸å¯å˜
- å¿…é¡»ä½¿ç”¨ `const` å…³é”®å­—å£°æ˜ã€ä¸”è¿›è¡Œ *æ˜¾ç¤ºç±»å‹æ ‡æ³¨*
- å¯ä»¥åœ¨ *ä»»ä½•* ä½œç”¨åŸŸä¸­å£°æ˜ï¼ˆåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸï¼‰ï¼Œä¸”åœ¨ç¨‹åºè¿è¡ŒæœŸé—´äºä½œç”¨åŸŸä¸­ä¸€ç›´æœ‰æ•ˆ
- åªèƒ½ç»‘å®šåˆ° *å¸¸é‡è¡¨è¾¾å¼*ï¼ˆæ— æ³•è¢« å‡½æ•°è°ƒç”¨ç»“æœ / è¿è¡Œæ—¶è®¡ç®—ç»“æœ èµ‹å€¼ï¼‰  

!!!note "å¸¸é‡ != *ä¸å¯å˜* å˜é‡"
    
### Shadowing

Rust æ”¯æŒé€šè¿‡ **ç›¸åŒå˜é‡å** å£°æ˜æ–°å˜é‡ï¼ˆå¯ä»¥ä¸æ—§å˜é‡ *ç±»å‹ä¸åŒ*ï¼‰ï¼ŒåŒæ—¶éšè—æ—§çš„åŒåå˜é‡

!!!note "Shadowing != `mut`"
    - å¦‚æœä¸ä½¿ç”¨ `let` å…³é”®å­—ï¼ˆShadowingï¼‰ï¼Œå¯¹é `mut` å˜é‡èµ‹å€¼ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯
    - ä½¿ç”¨ Shadowing å£°æ˜çš„æ–°å˜é‡ä¹Ÿæ˜¯ **ä¸å¯å˜** çš„

### æ•°æ®ç±»å‹

#### æ ‡é‡ç±»å‹

!!!info "æ•°å€¼è¿ç®—ï¼šåŠ å‡ä¹˜é™¤-å–ä½™ = `+-*/%`"

1. æ•´æ•°
    - æ— ç¬¦å·ä»¥ `u` å¼€å¤´ï¼Œæœ‰ç¬¦å·ä»¥ `i` å¼€å¤´
    - æ”¯æŒ `[8, 16m 32, 64, 128]` bit +  `(isize, usize)`ï¼Œåè€…ç”±è®¡ç®—æœºæ¶æ„å†³å®š
    - å­—é¢å€¼: é™¤ `Byte` å¤–éƒ½å¯ä»¥ä½¿ç”¨ç±»å‹åç¼€ï¼ˆå¦‚ `57u8`ï¼‰ã€é»˜è®¤ä¸º `i32`

        | è¿›åˆ¶ | Sample |
        | :--:| :------ |
        | Decimal | `98_222` å¢å¼ºå¯è¯»æ€§ |
        | Hex | `0xff` |
        | Octal | `0o77` |
        | Binary | `0b1010_1100`|
        | Byte(`u8`) | `b'A'` |

    - æº¢å‡º
        - åœ¨è°ƒè¯•æ¨¡å¼ä¸‹ï¼ŒRust ä¼šè‡ªåŠ¨æ£€æŸ¥æ•´æ•°æº¢å‡º + æŠ¥ panic
        - åœ¨å‘å¸ƒæ¨¡å¼ä¸‹ï¼ŒRust *ä¸ä¼šæ£€æŸ¥*ï¼Œå¹¶åœ¨å‘ç”Ÿæº¢å‡ºæ—¶è¿›è¡Œ `round`ï¼ˆä¸ä¼šæŠ¥ panicï¼‰

1. æµ®ç‚¹: æ”¯æŒ IEEE-754 æ ‡å‡†ä¸‹çš„ `(f32, f64)`ï¼Œé»˜è®¤ä¸º `f64`
2. å¸ƒå°”: ç»å…¸ `T/F`ï¼Œå  1 Byte
3. å­—ç¬¦ `char`: ä½¿ç”¨ `'` åŒ…è£¹ã€å  4 Byteï¼Œä¸º Unicode æ ‡é‡

#### å¤åˆç±»å‹

1. Tuple: é•¿åº¦å›ºå®šï¼ˆå£°æ˜åæ— æ³•æ”¹å˜ï¼‰

    ```rs
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // ä¸‹æ ‡è®¿é—®ï¼ˆä» 0 å¼€å§‹ï¼‰
    println!("{}", tup.0); 
    // è§£æ„
    let (x, y, z) = tup;
    ```

2. Array: å…ƒç´ ç±»å‹ä¸€è‡´ã€**é•¿åº¦å›ºå®š**ï¼Œå­˜æ”¾åœ¨ Stack

    > æ²¡æœ‰é•¿åº¦å¯å˜çš„ `Vector` çµæ´»

    - å¯ä»¥é€šè¿‡ä¸‹æ ‡è®¿é—®ï¼Œè¶Šç•Œæ—¶ *ç¼–è¯‘é€šè¿‡*ã€ä½†åœ¨è¿è¡Œæ—¶æŠ¥ panic

    ```rs
    let arr = [1,2,3];
    // ä¹Ÿå¯ä»¥æ˜¾ç¤ºå£°æ˜ [ç±»å‹;é•¿åº¦]
    let arr: [i32; 4] = [1,2,3,4];
    // å¦‚æœå…ƒç´ å…¨éƒ¨ç›¸ç­‰ï¼Œå¯ä»¥é€šè¿‡ [val;len] è¿›è¡Œæ‰¹é‡èµ‹å€¼
    let arr: [0;5]; // => arr = [0,0,0,0,0];
    ```

#### å­—ç¬¦ä¸²

1. å­—ç¬¦ä¸²å­—é¢é‡ï¼šç¨‹åºé‡Œå·²ç»å†™æ­»çš„å­—ç¬¦ä¸²å€¼ï¼ˆå†…å®¹ä¼šè¢«ç¡¬ç¼–ç è‡³å¯æ‰§è¡Œæ–‡ä»¶ï¼‰ï¼Œä¸å¯å˜
2. String ç±»å‹ï¼šèƒ½åœ¨ç¼–è¯‘æ—¶å­˜å‚¨é•¿åº¦æœªçŸ¥çš„æ–‡æœ¬ï¼Œå¯å˜ï¼ˆæœ¬è´¨æ˜¯å¯¹ `Vec<u8>` çš„åŒ…è£…ï¼‰

    åœ¨ Stack ä¸Šç”±ä¸‰éƒ¨åˆ†ç»„æˆã€å®é™…æ–‡æœ¬å†…å®¹æ”¾åœ¨ Heap ä¸Š
     
    1) `ptr` æŒ‡å‘å†…å­˜åœ°å€ 

    2) `len()` å®é™…é•¿åº¦ (å­—èŠ‚æ•°)

    3) `capacity` æœ€å¤§å®¹é‡ (ä» OS æ¯›æ¥çš„ç©ºé—´å¤§å°)

    ```rs
    // åˆ›å»º
    let mut s = String::new();         // ç©ºçš„
    let s = "sth".to_string();         // åªè¦å®ç°äº† Display trait çš„éƒ½èƒ½ç”¨
    let mut s = String::from('hello'); // åŸºäº å­—é¢å€¼ åˆå§‹åŒ–

    // æ›´æ–°
    s.push_str(" World!" / &str);      // å¾€åé¢å¡å­—ç¬¦ä¸²åˆ‡ç‰‡
    s.push('a');                       // å¾€åé¢å¡ char
    let s = s1 + &s2;                  // æ‹¼æ¥ï¼Œåé¢é‚£ä¸ªéœ€è¦æ˜¯å¼•ç”¨ (s1 ä¸èƒ½ç”¨ï¼Œä½† s2 è¿˜èƒ½ç”¨)
    let s = format!("{}-{}-{}", s1, s2, s2);   // è¿”å›ä¸€ä¸ªæ–°ä¸²ï¼ˆs1~s3 éƒ½å¯ä»¥ç»§ç»­ç”¨ï¼‰

    // éå†è®¿é—®ï¼ˆä¸æ”¯æŒç´¢å¼•ï¼‰ï¼šbytes() chars() ä½†è¿™ä¿©éƒ½ä¸å¤ªå¯¹ï¼Œå­—å‹ç°‡åˆä¸æä¾›
    // åˆ‡å‰²ï¼šåˆ‡ç‰‡ &s[..] æ˜¯æŒ‰ byte åˆ‡çš„ã€å¯èƒ½åˆ‡åˆ°åŠä¸ªå­—ç„¶åæŠ¥ panic
    ```

#### Struct

- Struct å®ä¾‹æ‹¥æœ‰å…¶æ‰€æœ‰æ•°æ®çš„æ‰€æœ‰æƒï¼Œåªè¦å®ä¾‹æœ‰æ•ˆã€å­—æ®µä¸€å®šæœ‰æ•ˆ

    > æœ‰ç”Ÿå‘½å‘¨æœŸæ—¶ï¼Œå­—æ®µå€¼ä¹Ÿå¯ä»¥æ˜¯å¼•ç”¨ï¼ˆä¿è¯ struct æœ‰æ•ˆæ—¶ã€å¼•ç”¨ä¸€å®šæœ‰æ•ˆï¼‰

    - Struct å®šä¹‰ï¼šå¯ä»¥ç”¨ `pub struct` å£°æ˜ä¸ºå…¬å…±ï¼ˆä½†å­—æ®µä»æ˜¯ç§æœ‰çš„ï¼‰

        ```rs
        // å°±æ˜¯ç®€å•çš„æŠŠä¸€äº›å±æ€§æ‹¼åœ¨ä¸€èµ·ï¼ˆæœ€åæ²¡æœ‰åˆ†å·ï¼‰
        struct User {
            username: String,
            email:    String,
            account:  u64,
            active:   bool,  // è¿™é‡Œä¹Ÿæœ‰é€—å·
        }
        ```
    
    - å®ä¾‹åŒ–

        ```rs
        /* å®ä¾‹åŒ–æ—¶ï¼Œéœ€è¦ä¸º *æ¯ä¸€ä¸ª* å­—æ®µæŒ‡å®šå€¼ï¼ˆé¡ºåºéšæ„ï¼‰
        * å½“ struct å®ä¾‹å¯å˜æ—¶ï¼Œæ‰€æœ‰å±æ€§ *å‡å¯å˜* => æ— æ³•å¯¹å•ä¸ªå±æ€§è¿›è¡ŒæŒ‡å®š
        */
        let mut usr1 = User {
            email:    String::from("e@addr"),
            username: String::from("John"),
            active:   true,
            account:  556,   // è¿™é‡Œä¹Ÿæœ‰é€—å·
        };

        // å¯ä»¥é€šè¿‡ .attribute è®¿é—® & èµ‹å€¼
        usr.active = false;
        ```

    - å¡ç»™å‡½æ•°
        ```rs
        // å¯ä»¥ä½œä¸ºå‡½æ•°è¿”å›å€¼
        fn build_usr(email: String, username: String) -> User {
            User {
                email, username,         // å˜é‡åä¸å±æ€§åä¸€è‡´æ—¶ï¼Œå¯ä»¥ç®€å†™ 
                active: true, account: 0,
            }
        }

        struct Rectangle { width: i32, length: i32, }
        // ä½¿ç”¨å¼•ç”¨ä½œä¸ºå½¢å‚ => åŸå˜é‡å°†ä¿æœ‰æ‰€æœ‰æƒ
        fn area(rect: &Rectangle) -> u32 { rect.width * rect.length }
        ```

    - æ›´æ–°è¯­æ³•ï¼šåŸºäºå·²æœ‰å®ä¾‹æ–°å»º

        ```rs
        let usr2 = User {
            email:    String::from("neo@addr"),
            username: String::from("Doe"),
            ..usr1    // å‰©ä¸‹å­—æ®µæ²¿ç”¨ usr1
        };
        ```

    - ç»“æ„ä½“æ–¹æ³•ï¼šéœ€è¦åœ¨ `impl` å—å†…å®šä¹‰ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ `self`ï¼ˆä¹Ÿå¯ä»¥æ˜¯å¼•ç”¨ï¼‰

        åœ¨è°ƒç”¨æ—¶ï¼ŒRust ä¼šè‡ªåŠ¨æ·»åŠ  `&, &mut, *`ï¼Œæ‰€ä»¥ `r.area() == (&r).area()`

        ```rs
        // ç›´æ¥ println!("{}", rect) ä¼šæŠ¥é”™ï¼Œéœ€è¦åŠ  trait / æ‰‹åŠ¨å®ç°
        #[derive(Debug)]    // {:?} = structName { attr: val } , {:#?} = åœ¨ attr é—´æ¢è¡Œ
        struct Rectangle {}

        impl Rectangle {
            fn can_hold(&self, r2: &Rectangle) -> bool {
                self.width > r2.width && self.length > r2.length
            }

            // getter (å› ä¸ºå±æ€§é»˜è®¤æ˜¯ç§æœ‰çš„)
            pub fn width(&self) -> i32 {
                slef.width
            }
        }

        // éœ€è¦é€šè¿‡å®ä¾‹è°ƒç”¨
        r1.can_hold(&r2);
        ```

    - å…³è”å‡½æ•°ï¼šåœ¨ `impl` å—å†…å®šä¹‰ï¼Œä½†ç¬¬ä¸€ä¸ªå‚æ•°ä¸æ˜¯ `self`ï¼ˆä¸€èˆ¬ç”¨äºæ„é€ å‡½æ•°ï¼‰

        ```rs
        impl Rectangle {
            // æ„é€ å‡½æ•°ï¼ŒåŒæ—¶éªŒè¯ a>0
            pub fn new_square(a: i32) -> Rectangle {
                if a < 0 { panic!("Less than 0"); }
                Rectangle { width: a, length: a}
            }
        }
        // æœ‰ç‚¹åƒé™æ€æ–¹æ³•ï¼Œé€šè¿‡ :: è°ƒç”¨
        let sq = Rectangle::new_square(10);
        ```

- Tuple Structï¼šæ•´ä½“æœ‰åå­—ï¼Œä½†é‡Œé¢çš„å…ƒç´ æ²¡æœ‰å±æ€§å

    ```rs
    struct Color(i32, i32, i32);  // æ²¡å¿…è¦ä¸º RGB å•ç‹¬å–å
    struct Point(i32, i32, i32);
    // black å’Œ origin æ˜¯ *ä¸åŒç±»å‹*ï¼ˆä¸åŒ tuple struct çš„å®ä¾‹ï¼‰
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
    ```

- Unit-Like Structï¼šæ²¡æœ‰ä»»ä½•å­—æ®µï¼Œé•¿å¾—åƒ `()`

    ç”¨äºåœ¨ç‰¹å®šç±»å‹ä¸Šå®ç° traitï¼Œä½†æœ‰æ²¡æœ‰éœ€è¦å­˜çš„ä¸œè¥¿

#### æšä¸¾

- Enumï¼š

    - Rust å…è®¸ä¸ºæšä¸¾å®šä¹‰ä¸åŒçš„æ•°æ®ç±»å‹ï¼Œä¹Ÿå¯ä»¥åœ¨ `impl` å—ä¸­ä¸ºå…¶å®ç°æ–¹æ³•
    - å¯ä»¥é€šè¿‡ `pub enum` å£°æ˜ä¸ºå…¬å…±çš„ã€æ­¤æ—¶æ‰€æœ‰å˜ä½“ *éƒ½æ˜¯å…¬å…±çš„*

    ```rs
    enum IpAddr {
        V4(u8, u8, u8. u8),
        V6(String),
    }

    let home =     IpAddr::V4(127,0,0,1);
    let loopback = IpAddr:V6(String::from("::1"));

    // ä½ ç”šè‡³å¯ä»¥å¾€é‡Œé¢åµŒ struct
    struct IpV4Addr {}
    struct IpV6Addr {}
    enum IpAddr {
        V4(IpV4Addr), V6(IpV6Addr),
    }
    ```

- Optionï¼šç”¨äºæè¿°æŸä¸ªå€¼å¯èƒ½å­˜åœ¨çš„ç±»å‹ + ä¸å­˜åœ¨çš„æƒ…å†µ

    - åœ¨é¢„å¯¼å…¥æ¨¡å—é‡Œï¼Œä½ å¯ä»¥ç›´æ¥ä½¿ç”¨ `Option<T>, Some(T), None`
    - `Option<T> != T`ï¼Œç¡®ä¿ `T` ç±»å‹ä¸€å®šéç©º

    ```rs
    enum Option<T> {
        Some(T), None,
    }

    let some_num = Some(5);          // i32
    let abs_num: Option<i32> = None; // æ²¡æ³•è‡ªåŠ¨æ¨æ–­
    ```

#### Vector `Vec<T>`

åœ¨å†…å­˜ä¸­è¿ç»­å­˜å‚¨å¤šä¸ª *ç›¸åŒç±»å‹* çš„å€¼ï¼ˆä½†ä½ å¯ä»¥å¥—ä¸€ä¸ª Enum é€ƒè¯¾ï¼‰

```rs
// åˆ›å»º
let mut v: Vec<i32> = Vec::new(); // åˆ›å»ºç©º Vecï¼Œéœ€è¦æ‰‹åŠ¨æŒ‡å®šç±»å‹
let v = vec![1,2,3];

// æ›´æ–°
v.push(1);

// è®¿é—®ï¼ˆä¸‹æ ‡ / getï¼‰
println!("{}", v[0]);  // OOB ä¼šæŠ¥ panic => ä¹Ÿå¯ä»¥å®šä¹‰å€Ÿç”¨ &v[0]
match v.get(0) {
    Some(v0) => println!("{}", v0);
    None => println!("Out Of Bound")
}

// éå† + å¯å˜å¼•ç”¨æ›´æ–°
let mut v = vec![...];
for i in &mut v {
    *i += 50;
}
```

#### HashMap

- å­˜å‚¨åœ¨ Heap ä¸Šçš„é”®å€¼å¯¹ï¼Œä½†å•æ¡æ•°æ®åŒæ„
- å®ç° Copy Trait çš„ä¼šå¤åˆ¶ä¸€ä»½ï¼Œæœ‰æ‰€æœ‰æƒçš„ä¼šæŠ¢èµ°+ç§»åŠ¨å€¼ï¼ˆå¯ä»¥é€šè¿‡æ’å…¥å¼•ç”¨é¿å…ï¼‰

```rs
use std::collections::HashMap;

// æ‰‹åŠ¨æ’å€¼
let mut scores: HashMap<String, i32> = HashMap::new();
scores.insert(String::from("aaa"), 32);

// é€šè¿‡ collect åŸºäºä¸¤ä¸ª arr åˆ›å»º
let keys = vec![String::from("a"), String::from("b")];
let vals = vec![10, 20];

let scores: HashMap<_, _> = // å¯ä»¥æ¨æ–­ï¼Œä½† collect å¯èƒ½è¿”å›å¤šç§ç±»å‹ã€æ‰€ä»¥è‡³å°‘è¦æŒ‡å®š HashMap
    keys.iter().zip(vals.iter()).collect;

// è®¿é—®: éœ€è¦æ‰‹åŠ¨å¤„ç† key ä¸å­˜åœ¨çš„æƒ…å†µ
let score = scores.get("ccc");
match score {
    Some(s) => println!("{}", s),
    None    => println!("None"),
}

// éå†ï¼ˆä½¿ç”¨å¼•ç”¨çš„è¯ï¼Œä¹‹åè¿˜èƒ½ç»§ç»­ç”¨ï¼‰
for (k, v) in &scores {}

// æ›´æ–°
scores.insert(String::from("aaa"), 64);    // è¦†ç›–åŸæ¥çš„ 32
let s = scores.entry("ccc").or_insert(50); // ä»…å½“ä¸å­˜åœ¨æ—¶æ’å…¥+è¿”å›æ–°å€¼å¼•ç”¨ï¼Œå¦åˆ™æä¾›åŸ val çš„å¯å˜å¼•ç”¨
*s += 1;                                   // å­˜åœ¨æ—¶ï¼Œv += 1
```

## 2 å‡½æ•°

- é€šè¿‡ `fn` å…³é”®å­—è¿›è¡Œå£°æ˜ã€å‘½åéµå¾ª snake case è§„èŒƒ

- å£°æ˜ä½ç½®å¯ä»¥ä½äº *è°ƒç”¨ä½ç½®ä¹‹å*

    ```rs
    // ä¸‹é¢ä¸ä¼šæŠ¥é”™ï¼ˆé‚£å¾ˆå‹å–„äº†ï¼‰
    fn main() { f(); }
    fn f() { println!("Another Func"); }
    ```

- å‡½æ•°ç­¾åä¸­å¿…é¡»æ˜¾å¼å£°æ˜ *æ¯ä¸ªå½¢å‚çš„ç±»å‹* 
- é»˜è®¤ä½¿ç”¨å‡½æ•°ä½“ä¸­æœ€åä¸€ä¸ª *è¡¨è¾¾å¼* ä½œä¸ºè¿”å›å€¼ï¼Œç±»å‹åœ¨ `->` åå£°æ˜

    ```rs
    fn plus_five(x: i32) -> i32 {
        x+5 // ä¸èƒ½åŠ åˆ†å·
    }
    ```

    - ä½ ä¹Ÿå¯ä»¥æå‰é€šè¿‡ `return` å…³é”®å­—è¿”å›

    - è¿˜å¯ä»¥è¿”å›ä¸€ä¸ª Tuple

        ```rs
        fn calc_len(s: String) -> (String, usize) {
            let l = s.len();
            (s, l)
        }
        ```

## 3 æ§åˆ¶æµ

#### åˆ†æ”¯
  
- IF/IF_ELSE: 

    - æ¡ä»¶å¿…é¡»ä¸º `bool` ç±»å‹ï¼ˆä¸ä¼šè‡ªåŠ¨è½¬æ¢ï¼‰ï¼Œä½†ä¸ç”¨å¥— `()`
    - å› ä¸º IF æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä½ ä¹Ÿå¯ä»¥æŠŠå®ƒä¸¢åˆ° `let` çš„å³ä¾§

    ```rs
    if      num<5 {}
    else if num>5 {}
    else          {}

    let num = if cond {5} else {6}; // ä½†è¿™ä¿©å€¼çš„ç±»å‹å¿…é¡»å…¼å®¹
    ```

- MATCH: å¿…é¡»ç©·ä¸¾ **æ‰€æœ‰** å¯èƒ½æ€§ï¼ˆæˆ–ç”¨ `_ => ()` ä½œä¸ºå…œåº•ï¼‰

    ```rs
    #[derive(Debug)]
    struct State {}

    enum Coin { 
        Penny, Nickel, Dime, 
        Quarter(State), 
    }

    fn coin_2_value(coin: Coin) -> u8 {
        match coin {
            Coin::Penny   => 1,
            Coin::Nickle  => 5,
            Coin::Dime    => 10,
            Coin::Quarter(state) => {
                println!("from: {}", state);
                25
            },
        }
    }
    ```

    - ä½ ä¹Ÿå¯ä»¥ç”¨æ¥å¤„ç† `Option<T>` é‡Œå­˜åœ¨ç©ºå€¼çš„æƒ…å†µ
  
        ```rs
        fn plus_one(x: Option<i32>) -> Option<i32> {
            match x {
                None    => None,
                Some(i) => Some(i+1),
            }
        }
        ```

- IF LET: åªå…³å¿ƒä¸€ç§ caseï¼Œå…¶ä»–æ”¾ç”Ÿ

    ```rs
    let v = Some(3);

    if let Some(3) = v {
        println!("Got Three");
    } else {
        println!("Other");
    }
    ```

#### å¾ªç¯

> ç†Ÿæ‚‰çš„è€ä¸‰å¥—ï¼ˆLOOP, WHILE, FORï¼‰

```rs
loop {
    if cond { break; }
    else    { continue; }
}

while num != 0 { num = num-1; }

// FOR ä¸€èˆ¬æ‹¿æ¥éå†æ•°ç»„
let arr = [1,2,3,4,5];
for ele in arr.iter() { println!("{}", ele); }
// ä½ ä¹Ÿå¯ä»¥ç”¨æ¥éå† Rangeï¼ˆå·¦é—­å³å¼€ï¼‰
for ele in (1..4).rev() {} // ç”Ÿæˆçš„ range = [3,2,1]
```

## 4 æ‰€æœ‰æƒ ğŸŒŸ 

!!!info "æŠŠæ•°æ® **å­˜** åœ¨ Stack ä¸Šè¦æ¯”å­˜åœ¨ Heap ä¸Šå¿«å¾—å¤š"
    - åœ¨ Stack ä¸Šï¼Œæ“ä½œç³»ç»Ÿä¸éœ€è¦æœç´¢ç©ºé—´ => ç›´æ¥æ”¾åœ¨æ ˆé¡¶å°±è¡Œ
    - åœ¨ Heap ä¸Šï¼ŒOS éœ€è¦å…ˆæ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºé—´ï¼Œå¹¶æ›´æ–°ç›¸å…³è®°å½•ä»¥ä¾¿è¿›è¡Œä¸‹æ¬¡åˆ†é…

!!!info "åœ¨ Stack ä¸Š **è®¿é—®æ•°æ®** è¦æ¯” Heap å¿«å¾—å¤š"
    Heap ä¸­çš„æ•°æ®å¿…é¡»é€šè¿‡æŒ‡é’ˆè®¿é—®


- Rust åŸºäºæ‰€æœ‰æƒç³»ç»Ÿç®¡ç†å†…å­˜ï¼Œè¿™ä¸€ feature ä½¿å¾— Rust æ— éœ€è¿›è¡Œ GC å³å¯ä¿è¯å†…å­˜å®‰å…¨
    
- è¯¥ç³»ç»ŸåŒ…å«ä¸€ç»„åœ¨ *ç¼–è¯‘* æ—¶æ£€æŸ¥çš„è§„åˆ™ã€åœ¨ *è¿è¡Œ* æ—¶ä¸ä¼šäº§ç”Ÿä»»ä½•é¢å¤–å¼€é”€

    1. æ¯ä¸ªå€¼éƒ½æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼ˆå¯¹åº”çš„å˜é‡ï¼‰
    2. å½“æ‰€æœ‰è€…è¶…å‡ºä½œç”¨åŸŸåæ—¶ï¼Œåˆ é™¤å€¼

- æ‰€æœ‰æƒç³»ç»Ÿè§£å†³äº†ä»¥ä¸‹é—®é¢˜ï¼š
  
    1. ä»£ç çš„å“ªäº›éƒ¨åˆ†æ­£åœ¨ä½¿ç”¨ Heap ä¸Šçš„å“ªäº›æ•°æ®
    2. æœ€å°åŒ– Heap ä¸­å­˜å‚¨çš„é‡å¤æ•°æ®
    3. æ¸…ç† Heap ä¸Šæœªä½¿ç”¨çš„æ•°æ®ï¼Œä»¥é¿å…ç©ºé—´ä¸è¶³

### å…³äºå˜é‡

!!!info "Rust *ä¸ä¼šè‡ªåŠ¨åˆ›å»º Deep Copy*ï¼Œä»»ä½•è‡ªåŠ¨èµ‹å€¼éƒ½æ˜¯å»‰ä»·çš„"

- Copy Trait: ä¸¤ä¸ªå˜é‡çš„å€¼å‡åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œæ‰€ä»¥ä¼šæœ‰ *ä¸¤ä¸ª* 5 è¢«å‹è¿› Stack

    - æ‰€æœ‰çš„ æ•´æ•°ã€å¸ƒå°”ã€å­—ç¬¦ éƒ½å…·æœ‰è¯¥ç‰¹æ€§
    - è‹¥ Tuple å†…ä»…åŒ…å«ä¸Šè¿°ç±»å‹çš„æ•°æ®ï¼Œåˆ™ä¹Ÿå…·å¤‡è¯¥ç‰¹æ€§

    ```rs
    let x = 5;
    let y = x;
    ```

- Drop Trait: `s2` å ç”¨äº† `(ptr,len,capacity)`ï¼ˆå‘ç”Ÿ Moveï¼‰

    æ‰€æœ‰éœ€è¦ åˆ†é…å†…å­˜/èµ„æº çš„ç±»å‹éƒ½å…·æœ‰è¯¥ç‰¹æ€§

    ```rs
    let s1 = String::from('test');
    let s2 = s1; // æ­¤æ—¶ s1 å¤±æ•ˆï¼ˆåªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼‰
    ```

### å…³äºå‡½æ•°

ç±»ä¼¼çš„ï¼Œåœ¨ å°†å®å‚ä¼ é€’ç»™å‡½æ•°/åˆ›å»ºè¿”å›å€¼ æ—¶ï¼Œè¿™äº›å€¼å°†å‘ç”Ÿ Copy/Move

```rs
fn test(a: i32, b: String) {
    // a æ˜¯ Copy, ä¿®æ”¹ä¸ä¼šå½±å“åŸæ¥çš„
    // b æ˜¯ Move
}

let x = 5;
let y = String::from('test');
test(x, y);             // å¯ä»¥æ¢æˆ test(x, y.clone()) è¿›è¡Œæ˜¾å¼ copy
println!(f"y = {}", y); // âš ï¸ y å·²ç»ä¸å†æ‹¥æœ‰æ‰€æœ‰æƒ
```

???info "String æ‰€æœ‰æƒåå¤æ¨ªè·³"
    ```rs
    fn main() {
        let mut out = String::from("Hello");
        out = take_over(out);
        println!("Then, out: {}", out); // => Hello_Side
    }

    fn take_over(mut inn: String) -> String {
        println!("inn: {}", inn);
        inn.push_str("_Side");
        return inn;                    // å½’è¿˜æ‰€æœ‰æƒ
    }
    ```
    
???info "å¥‡æ€ªç‰¹æ€§"
    ```rs
    fn main() {
        let out = String::from("Hello"); // è¿™é‡Œå®å‚æ²¡æœ‰ mut
        out = take_over(out);
    }

    fn take_over(mut inn: String) {     // å½¢å‚å¿…é¡»æœ‰ mutï¼ˆè¦æ‰§è¡Œ push_strï¼‰
        println!("inn: {}", inn);
        inn.push_str("_Side");          // è¿˜çœŸç»™æ”¹äº†
    }
    ```

### å¼•ç”¨ä¸å€Ÿç”¨

> æ‰‹åŠ¨æŠŠ Move ç±»çš„æ‰€æœ‰æƒä¼ æ¥ä¼ å»æœ‰ç‚¹å‘†ï¼Œæœ‰æ²¡æœ‰ä»€ä¹ˆå¥½çš„è§£å†³æ–¹æ¡ˆå‘¢

- å¼•ç”¨ï¼šå…è®¸ä½¿ç”¨æŸäº›å€¼è€Œä¸å–å¾—æ‰€æœ‰æƒï¼ˆåˆ›å»ºäº†ä¸€ä¸ªæŒ‡å‘åŸå˜é‡çš„æŒ‡é’ˆï¼‰

    ```rs
    let s1 = String::from('tt');
    let len = get_len(&s1);           // è¿™é‡Œä¼ å¼•ç”¨

    fn get_len(s: &String) -> usize { // æ³¨æ„å½¢å‚
        s.len()
    }
    ```

- å¼•ç”¨ *é»˜è®¤* æ˜¯ä¸å¯å˜çš„ï¼Œä½†ä¹Ÿå¯ä»¥é€šè¿‡ `mut` æ‰‹åŠ¨æŒ‡å®š

    ```rs
    let mut s1 = String::from('tt');      // æœ¬ä½“èƒ½å˜
    let len = get_len(&mut s1);           // åˆ›å»ºå¯å˜çš„å¼•ç”¨
    fn get_len(s: &mut String) -> usize { // å¡åœ¨ & åé¢
        s.push_str("_222");
        s.len()
    }
    ```

    - *åŒä¸€ä½œç”¨åŸŸ* å†…ï¼Œæ¯ä»½æ•°åªèƒ½æœ‰ *ä¸€ä¸ªå¯å˜* å¼•ç”¨ï¼ˆé¿å…æ•°æ®ç«äº‰ï¼‰
    - å¯ä»¥é€šè¿‡åˆ›å»ºæ–°çš„ä½œç”¨åŸŸè¿›è¡Œè§„é¿

        ```rs
        let mut s = String::from('t');
        {
            let s1 = &mut s;
        }   // è¿™æ—¶å€™ s1 å·²ç»å™¶äº†
        let s2 = &mut s;
        ```

    - æ— æ³•åŒæ—¶æ‹¥æœ‰ å¯å˜-ä¸å¯å˜å¼•ç”¨ï¼ˆæ„ä¹‰å†²çªï¼‰ã€ä½†å¯ä»¥åŒæ—¶å­˜åœ¨å¤šä¸ªä¸å¯å˜å¼•ç”¨

        ```rs
        let mut s = String::from('t');
        let s1 = &s;
        let s2 = &s;
        let s3 = &mut s;  // âš ï¸ é‚£ s æ˜¯å˜è¿˜æ˜¯ä¸å˜å•Š
        ```

- Dangling Ref æ‚¬ç©ºå¼•ç”¨ï¼šRust ç¼–è¯‘å™¨ä¼šç›´æ¥æŠ¥é”™

    ```rs
    let r = dangle();
    fn dangle() -> &String {
        let s = String::from('sth');
        &s
    } // âš ï¸ æ­¤æ—¶ s è¢«æ¸…ç†ã€&s æŒ‡å‘æ‚¬ç©ºä½ç½®
    ```

### åˆ‡ç‰‡

- Slice ä¹Ÿæ˜¯ä¸€ç§ *ä¸å–å¾—æ‰€æœ‰æƒ* çš„æ•°æ®ç±»å‹
- æœ¬è´¨æ˜¯æŒ‡å‘ String ä¸­ *éƒ¨åˆ†å†…å®¹* çš„å¼•ç”¨ï¼Œä½†åªæœ‰ `(ptr, len)` å€¼

    ```rs
    let s = String::from("Hello World");
    let hello = &s[0..5]; // ä¹Ÿå¯ä»¥å†™æˆ [..ed] / [bg..] / [..]

    fn first_word(s: &String) -> &str { // è¿”å›çš„æ˜¯åˆ‡ç‰‡
        let bytes = s.as_bytes(); // arr<u8>
        for (i, &item) in bytes.inter().enumerate() {
            if item == b' ' { return &s[..i]; }
        }
        &s[..];
    }

    // ä½†ä¸€èˆ¬ä¼šç›´æ¥ä½¿ç”¨ å­—ç¬¦ä¸²åˆ‡ç‰‡ ä½œä¸ºå½¢å‚ç±»å‹ï¼ˆå¯ä»¥å…¼å®¹ String & &str ç±»å‹çš„å®å‚ï¼‰
    fn find(s: &str) {}
    let s1 = String::from("xxxx"); // => find(&s1[..]) åˆ›å»ºæ•´ä¸ª String çš„åˆ‡ç‰‡
    let s2 = "yyyy";               // => find(s2)      ç›´æ¥å¾€é‡Œä¸€ä¸¢
    ```

- å­—ç¬¦ä¸²å­—é¢å€¼å®é™…ä¸Šä¹Ÿæ˜¯åˆ‡ç‰‡ï¼ˆæ•°æ®ç›´æ¥è¢«å­˜å‚¨åœ¨äºŒè¿›åˆ¶ç¨‹åºä¸­ï¼‰

    ```rs
    let s = "Hello"; // s is &str
    ```

## 5 åŒ…ä¸æ¨¡å—

æ„Ÿè§‰ Rust çš„æ¨¡å—ç³»ç»Ÿæœ‰ç‚¹é­”å¹»ï¼š

- Packageï¼ˆåŒ…ï¼‰ï¼š
    - æ˜¯ Cargo çš„ç‰¹æ€§ï¼Œå¯ä»¥ç”¨äºæ„å»ºã€æµ‹è¯•ã€å…±äº« crate
    - åŒ…å« `Cargo.toml`ï¼Œç”¨äºæè¿°å¦‚ä½•æ„å»º Cratesï¼ˆå¦‚ï¼šå¯¼å…¥å¤–éƒ¨ä¾èµ–ï¼‰
    - å¯ä»¥æ‹¥æœ‰ 0/1 ä¸ª LibCrateï¼Œä½†å¯ä»¥æ‹¥æœ‰ä»»æ„ä¸ª binCrateï¼ˆæ”¾åœ¨ `src/bin` ä¸‹ï¼‰
- Crateï¼ˆå•å…ƒåŒ…ï¼‰ï¼š
    > æˆ–è®¸å¯ä»¥è®¤ä¸ºæ˜¯å•ä¸ª Rust æ–‡ä»¶ï¼Ÿ
    - ä¸€æ£µæ¨¡å—æ ‘ï¼Œå¯ä»¥ç”Ÿæˆ Lib / å¯æ‰§è¡Œæ–‡ä»¶
    - å…·æœ‰ binary / library ä¸¤ç§ç±»å‹
    - Crate Root æ˜¯ç¼–è¯‘çš„å…¥å£æ–‡ä»¶ï¼Œç»„æˆ Crate çš„ æ ¹ Module
        - binCrate çš„ root é»˜è®¤ä¸º `src/main.rs`
        - LibCreate çš„ root é»˜è®¤ä¸º `src/lib.rs`
- Module-Useï¼ˆæ¨¡å—ï¼‰ï¼š
    - åœ¨å•ä¸ª Crate å†…å¯¹ä»£ç è¿›è¡Œåˆ†ç»„ï¼Œç”¨äºæ§åˆ¶ä»£ç ç»„ç»‡ã€ä½œç”¨åŸŸã€ç§æœ‰ Path
    - ä½¿ç”¨ `mod [ModName];` æ—¶ï¼Œä¼šæŠŠ `src/ModName.rs` ä¸­çš„ä»£ç å…¨è´´è¿›æ¥
    - é€šè¿‡ `mod` å…³é”®å­—å®šä¹‰ã€æ”¯æŒåµŒå¥—
    - å¯ä»¥é€šè¿‡ `as` ä¸ºå¼•å…¥è·¯å¾„æŒ‡å®šåˆ«å: `use std::io::Result as IoResult`
    - å¯ä»¥é€šè¿‡ `pub use` é‡æ–°å¯¼å‡ºåç§°ï¼ˆé»˜è®¤æ˜¯ç§æœ‰çš„ï¼‰: `pub use crate::front_of_house::hosting`
    - å¯ä»¥é€šè¿‡åµŒå¥—è·¯å¾„å¼•å…¥åŒå‰ç¼€ä¸‹çš„å¤šä¸ªæ¡ç›®ï¼š

        ```rs
        use std::{cmp::Ordering, io};
        use std::io::{self, Write};  // åŒæ—¶å¼•å…¥ std::io + std::io::Write
        use std::collections::*;     // å¼•ä¸€å¨
        ```

- Pathï¼ˆè·¯å¾„ï¼‰ï¼šç”¨äºä¸º structã€funcã€module å‘½å
    - ç»å¯¹è·¯å¾„ï¼šä» create root å¼€å§‹ï¼Œé€šè¿‡ crateName / å­—é¢å€¼ "crate" è®¿é—®
    - ç›¸å¯¹è·¯å¾„ï¼šä»å½“å‰ Module å¼€å§‹ï¼Œé€šè¿‡ self / super / Module æ ‡è¯†ç¬¦ è®¿é—®

!!!info "Rust ä¸­çš„æ‰€æœ‰æ¡ç›®é»˜è®¤éƒ½æ˜¯ç§æœ‰çš„"
    - å…„å¼Ÿæ¨¡å—ä¹‹é—´å¯ä»¥äº’ç›¸è°ƒç”¨
    - çˆ¶æ¨¡å— *æ— æ³•ä½¿ç”¨* å­æ¨¡å—ä¸­çš„ç§æœ‰æ¡ç›®
    - è‡ªæ¨¡å—å¯ä»¥ä½¿ç”¨æ‰€æœ‰ *ç¥–å…ˆæ¨¡å—* ä¸­çš„æ¡ç›®ï¼ˆå› ä¸ºå¥—åœ¨ä¸Šä¸‹æ–‡é‡Œé¢ï¼‰

```rs title="main.rs"
fn test() {}

mod front_of_house { // å‰å°è¡Œä¸ºï¼ˆprivateï¼‰
    pub mod hosting {
        pub fn add_to_waitlist() {} // éœ€è¦é€çº§æš´éœ²å‡ºå»}
        fn seat_at_table()   {}
    }
    mod serving {
        fn take_oreder()  {}
        fn serve_order()  {}
        fn take_payment() {}
    }
    fn test() {
        crate::test();    // ç»å¯¹è·¯å¾„
        super::test();    // ç›¸å¯¹è·¯å¾„ï¼ˆé€€ä¸€çº§ï¼‰
    }
}

pub fn eat_at_restaurant() {
    // ç»å¯¹è·¯å¾„è°ƒç”¨
    crate::front_of_house::hosting::add_to_waitlist();
    // ç›¸å¯¹è·¯å¾„è°ƒç”¨
    front_of_house::hosting::add_to_waitlist();
    /* é€šè¿‡ use å¼•å…¥åï¼Œç›¸å¯¹è·¯å¾„å¯ä»¥æ›´çŸ­ä¸€ç‚¹
     * use crate::front_of_house::hosting => ä¹Ÿå¯ä»¥ use <ç›¸å¯¹è·¯å¾„>
     * hosting::add_to_waitlist(); 
     * å‡½æ•°é€šå¸¸å¼•ç”¨åˆ°çˆ¶æ¨¡å—ï¼Œstruct/enum é€šå¸¸å¼•ç”¨åˆ°æœ¬ä½“ */
}
```

## 6 é”™è¯¯å¤„ç†

Rust æ²¡æœ‰ try-catch çš„æœºåˆ¶

- `panic!`ï¼ˆä¸å¯æ¢å¤ï¼‰ï¼šå¯ä»¥æ‰‹åŠ¨è§¦å‘ `panic!("crash 4 fun")`
  
    - é»˜è®¤ï¼šæ‰“å°é”™è¯¯ä¿¡æ¯ -> å±•å¼€ã€æ¸…ç†è°ƒç”¨æ ˆ -> é€€å‡ºç¨‹åº
    - ä¹Ÿå¯ä»¥é€šè¿‡é…ç½® `panic = 'abort'` ç›´æ¥ä¸­æ–­ï¼ˆæ­¤æƒ…å†µä¸‹å†…å­˜ç”± OSã€è€Œé Rust æ¸…ç†ï¼‰
    - å¯ä»¥è®¾ç½®ç¯å¢ƒå˜é‡ `RUST_BACKTRACE=1` å®šä½å…·ä½“æŠ¥é”™çš„ä»£ç 

- `enum Result<T, E>{ Ok(T), Err(E), }`(å¯æ¢å¤):
  
    - `main()` ä¹Ÿèƒ½è¿”å› `Result<(), Box<dyn Err>>`ï¼Œåè€…å…œåº•äº†ä»»ä½•å¯èƒ½çš„é”™è¯¯ç±»å‹
    - `T` ä¸ºæ“ä½œæˆåŠŸæ—¶è¿”å›çš„ç±»å‹ï¼Œ`E` ä¸ºå¤±è´¥æ—¶çš„è¿”å›ç±»å‹
    - éœ€è¦é€šè¿‡ match å¤„ç†

        ```rs
        let f = File::open(file_url); // è¿”å› Result
        let f = match f {
            Ok(file) => file,
            Err(err) => match err.kind() { // é€‚é…ä¸åŒé”™è¯¯
                ErrorKind::NotFound => match File::create(file_url) {
                    Ok(fc) => fc,
                    Err(e) => panic!("Can't create {:?}", e),
                },
                other_e    => panic!("Can't open {:?}", other_e),
            },
        };
        ```

        - é€šè¿‡ `unwrap` æ”¹å†™ï¼šOk ç›´æ¥è¿”å›ï¼ŒErr æŠ¥ panicï¼ˆä¿¡æ¯ä¸èƒ½è‡ªå®šä¹‰ï¼‰
        - é€šè¿‡ `expect` æ”¹å†™ï¼šOk ç›´æ¥è¿”å›ï¼ŒErr æŠ¥è‡ªå®šä¹‰ panic

- é”™è¯¯ä¼ æ’­ï¼šè¿”å› Resultï¼ŒErr ä¸¢ç»™ caller å¤„ç†

    ```rs
    fn read_file(file_url: &String) -> Result<String, io::Error> {
        let mut s = String::new();

        let mut f = match  File::open(file_url) {
            Ok(file) => file,
            Err(e)   => return Err(e),
        };
        
        return match f.read_to_string(&mut s) {
            Ok(_)  => Ok(s),
            Err(e) => Err(e),
        };
    }

    // ä¸Šé¢çš„ä¸€å¨ç­‰ä»·äº
    fn read_file(file_url: &String) -> Result<String, io::Error> {
        let mut s = String::new();
        let mut f = File::open(file_url)?; // è¿™é‡Œæœ‰ä¸ªé—®å·
        f.read_to_string(&mut s)?;         // è¿™é‡Œæœ‰ä¸ªé—®å·
        Ok(s)
    }

    // è¿˜æœ‰é“¾å¼è°ƒç”¨ç‰ˆæœ¬
    fn read_file(file_url: &String) -> Result<String, io::Error> {
        let mut s = String::new();
        File::open(file_url)?.read_to_string(&mut s)?;
        Ok(s)
    }
    ```

- é”™è¯¯ç±»å‹è½¬æ¢ï¼š`std::convert::From` ä¸­çš„ `from()` å¯ä»¥æ”¹å˜é”™è¯¯ç±»å‹

    ç”± `?` ç®€åŒ–çš„é”™è¯¯ä¼šç”± `from` éšå¼è½¬åŒ–ä¸ºè¿”å›å€¼ä¸­å®šä¹‰çš„é”™è¯¯ç±»å‹ï¼ˆä½†å¿…é¡»å®ç°å¯¹åº”ç±»å‹çš„è½¬åŒ–å‡½æ•°ï¼‰

## 7 æ³›å‹ï¼Œtraitï¼Œç”Ÿå‘½å‘¨æœŸ

### æ³›å‹

- ç”±ç¼–è¯‘å™¨å°† `T` æ›¿æ¢ä¸ºå…·ä½“æ•°æ®ç±»å‹ï¼ˆå¯ä»¥ç”¨å…¶ä»–å¤åˆ CamelCase çš„åç§°ï¼‰

- æ³›å‹å‡½æ•°ï¼š

    ```rs
    // å› ä¸ºæ¶‰åŠæ¯”è¾ƒæ“ä½œï¼Œæ‰€ä»¥ T å¿…é¡»å®ç°ç‰¹å®š trait
    fn max<T: std::cmp::PartialOrd + Clone>(list: [T]) -> &T {
        let mut maxx = &list[0];
        for item in list {
            if item > &maxx { maxx = item; }
        }
        maxx
    }
    ```

- æ³›å‹ç»“æ„ä½“ (åœ¨ enum ä¸­ä¹Ÿèƒ½ç”¨)

    ```rs
    struct Point<T> {
        x: T, y: T,    // å¿…é¡»ç±»å‹ä¸€æ ·
    }
    impl<T> Point<T> { // é’ˆå¯¹æ‰€æœ‰ç±»å‹å®ç°
        pub fn x(&self) -> &T {
            &self.x
        }
        // æ–¹æ³•çš„æ³›å‹å¯ä»¥å’Œç»“æ„é¢˜ä¸ä¸€æ ·
        fn mixup<V, W>(self, otehr: Point<V,W>) -> Point<T, W> {
            Point {
                x: self.x,
                y: other.y,
            }
        }
    }
    impl Point<i32> {  // ä»…é’ˆå¯¹å…·ä½“ç±»å‹å®ç°
        pub fn x(&self) -> &i32 {
            &self.x
        }
    }

    struct Point<T, U> {
        x: T, y: U,    // ç±»å‹å¯ä»¥ä¸åŒ   
    }
    ```

### Trait

- åªæœ‰æ–¹æ³•çš„ç­¾åï¼Œæ²¡æœ‰å…·ä½“å®ç°
- å£°æ˜ç‰¹å®šç±»å‹å…·æœ‰æŸç§ä¸å…¶ä»–ç±»å‹å…±äº«çš„åŠŸèƒ½ï¼ˆæœ‰ç‚¹åƒ JAVA çš„ç©ºæ¥å£ï¼‰
- å¯ä»¥å°† æ³›å‹ æ”¯æŒèŒƒå›´é™åˆ¶äº å®ç°äº†ç‰¹å®šè¡Œä¸ºçš„ç±»å‹
- è·¨ crate ä½¿ç”¨æ—¶ï¼Œéœ€è¦åŒæ—¶å¼•å…¥ trait + å¯¹åº”ç±»å‹
- å½“ä¸”ä»…å½“ ç±»å‹/trait ä¸­è‡³å°‘æœ‰ä¸€ä¸ªåœ¨æœ¬åœ°å®šä¹‰æ—¶æ”¯æŒå®ç°ï¼ˆå¦åˆ™å¯èƒ½å­˜åœ¨å¤šä¸ªå®ç°ï¼‰

```rs
// å®šä¹‰
pub trait Summary {
    fn summarize(&self) -> String;
    fn suma(&self) -> String {      // é»˜è®¤å®ç°
        self.summarize();           // å¯ä»¥è°ƒå…„å¼Ÿï¼ˆå³ä½¿æ²¡æœ‰é»˜è®¤å®ç°ï¼‰
        String::from("Read more...")
    }
}

// å®ç° trait
impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.usr, self.msg)
    }
    // ä¹Ÿå¯ä»¥æ‰‹åŠ¨é‡å†™ fn summa(&self) -> Srting {}
}
// æœ‰æ¡ä»¶çš„å®ç° Trait
impl<T: Display> toString for T {}

// é™åˆ¶å‚æ•°ç±»å‹ï¼ˆåŒæ—¶å®ç° Summary & Displayï¼‰
pub fn notify(item: impl Summary + Display) {}
pub fn notify<T: Summary + Dispay, U: Clone + Debug>(item1: T, item2: U) {} // é•¿
pub fn notify<T, U>(item1: T, item2: U) 
    where T: Summary + Display, 
          U: Clone + Debug, {}

// é™åˆ¶è¿”å›å€¼ç±»å‹ï¼ˆä½†åªèƒ½è¿”å›ä¸€ç§å…·ä½“ç±»å‹ï¼‰
pub fn notify() -> impl Summary {}

// æœ‰æ¡ä»¶çš„å®ç°æ–¹æ³•
impl<T: Display+PartialOrd> Point<T> {
    fn cmp_display(&self) {}
}
```

### ç”Ÿå‘½å‘¨æœŸ

- "ç”Ÿå‘½å‘¨æœŸ" å³ å¼•ç”¨ä¿æŒæœ‰æ•ˆ çš„ä½œç”¨åŸŸï¼Œç›®æ ‡æ˜¯é¿å… dangling ref

- ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨
    - ä»¥ `'` å¼€å¤´ã€å…¨å°å†™ï¼Œæ”¾åœ¨å¼•ç”¨ç¬¦å· `&` ä¹‹å
    -  *ä¸ä¼š* å½±å“å¼•ç”¨çš„å®é™…ç”Ÿå‘½å‘¨æœŸé•¿åº¦ã€åªæ˜¯æè¿°ä¸åŒç”Ÿå‘½å‘¨æœŸä¹‹é—´çš„å…³ç³»

- å‡½æ•°çš„æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°

    å‡½æ•°è¿”å› *å¼•ç”¨* æ—¶ï¼Œè¿”å›å€¼ç”Ÿå‘½å‘¨æœŸè‡³å°‘ä¸ä¸€ä¸ªå‚æ•°åŒ¹é…

    ```rs title="åŒæ—¶ä½¿ç”¨æ³›å‹ + ç”Ÿå‘½å‘¨æœŸ"
    // 'a ä¸º x&y ç”Ÿå‘½å‘¨æœŸ *é‡å * çš„éƒ¨åˆ†
    // ä¸¤ä¸ªå‚æ•°+è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ >= 'a
    fn longer<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
        where T: Display,
    {
        println!("Announce {}", ann);
        if x.len() > y.len() { return x; }
        else                 { return y; }
    }
    ```

- Struct å®šä¹‰çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼šå­—æ®µä¸­å­˜åœ¨å¼•ç”¨

    ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¹Ÿæ˜¯ struct ç±»å‹çš„ä¸€éƒ¨åˆ†

    ```rs
    struct Sample<'a> {
        part: &'a str,  // Part æ´»å¾—è¦æ¯” Sample å®ä¾‹é•¿
    }
    ```

    - æ–¹æ³•ç­¾åçš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼ˆé€šå¸¸å¯ä»¥é»˜è®¤æ¨å¯¼ï¼‰

        å¼•ç”¨å’Œ struct å­—æ®µå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸç»‘å®š / ç‹¬ç«‹å¼•ç”¨

        ```rs
        // impl & structName ä¹‹åçš„ <'a> ä¸å¯çœç•¥
        impl<'a> Sample<'a> {}
        ```

- é™æ€ç”Ÿå‘½å‘¨æœŸ `static` == æ•´ä¸ªç¨‹åºçš„æŒç»­æ—¶é—´

